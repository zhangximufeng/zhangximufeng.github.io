<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>UDP | Myfun&#39;s Blog</title>
    <meta name="description" content="网络">
    <link rel="icon" href="/favicon.ico">
    <meta name="keywords" content="网络 协议">
    <link rel="preload" href="/assets/css/0.styles.6bc9bf16.css" as="style"><link rel="preload" href="/assets/js/app.35b69267.js" as="script"><link rel="preload" href="/assets/js/9.5cab2997.js" as="script"><link rel="prefetch" href="/assets/js/10.a2f6c6ac.js"><link rel="prefetch" href="/assets/js/100.24b9a366.js"><link rel="prefetch" href="/assets/js/101.085f0585.js"><link rel="prefetch" href="/assets/js/102.66d5674f.js"><link rel="prefetch" href="/assets/js/103.7f71429c.js"><link rel="prefetch" href="/assets/js/104.13b0f535.js"><link rel="prefetch" href="/assets/js/105.0a093e85.js"><link rel="prefetch" href="/assets/js/106.a4a1db62.js"><link rel="prefetch" href="/assets/js/107.2634aacf.js"><link rel="prefetch" href="/assets/js/108.b393516d.js"><link rel="prefetch" href="/assets/js/109.769b78fb.js"><link rel="prefetch" href="/assets/js/11.fb483cc4.js"><link rel="prefetch" href="/assets/js/12.24a41994.js"><link rel="prefetch" href="/assets/js/13.a4762474.js"><link rel="prefetch" href="/assets/js/14.4a737bc9.js"><link rel="prefetch" href="/assets/js/15.548f4e99.js"><link rel="prefetch" href="/assets/js/16.b0d2654c.js"><link rel="prefetch" href="/assets/js/17.d43ab467.js"><link rel="prefetch" href="/assets/js/18.0c8f5f87.js"><link rel="prefetch" href="/assets/js/19.19ef59f8.js"><link rel="prefetch" href="/assets/js/2.436a35aa.js"><link rel="prefetch" href="/assets/js/20.24296203.js"><link rel="prefetch" href="/assets/js/21.c486888f.js"><link rel="prefetch" href="/assets/js/22.7e2305f9.js"><link rel="prefetch" href="/assets/js/23.e55bab1b.js"><link rel="prefetch" href="/assets/js/24.1468433c.js"><link rel="prefetch" href="/assets/js/25.6d82837f.js"><link rel="prefetch" href="/assets/js/26.3c4b2f18.js"><link rel="prefetch" href="/assets/js/27.21725a4f.js"><link rel="prefetch" href="/assets/js/28.db16c479.js"><link rel="prefetch" href="/assets/js/29.cb9512e5.js"><link rel="prefetch" href="/assets/js/3.5c82c0f7.js"><link rel="prefetch" href="/assets/js/30.a4c25096.js"><link rel="prefetch" href="/assets/js/31.81741530.js"><link rel="prefetch" href="/assets/js/32.da6d2ac6.js"><link rel="prefetch" href="/assets/js/33.f6164ecd.js"><link rel="prefetch" href="/assets/js/34.0344ad22.js"><link rel="prefetch" href="/assets/js/35.07d4c8d3.js"><link rel="prefetch" href="/assets/js/36.2c6adcff.js"><link rel="prefetch" href="/assets/js/37.ceb5e95e.js"><link rel="prefetch" href="/assets/js/38.d39e96e5.js"><link rel="prefetch" href="/assets/js/39.fcf34164.js"><link rel="prefetch" href="/assets/js/4.267db630.js"><link rel="prefetch" href="/assets/js/40.bdf31768.js"><link rel="prefetch" href="/assets/js/41.cc61eccd.js"><link rel="prefetch" href="/assets/js/42.042e4349.js"><link rel="prefetch" href="/assets/js/43.b385d348.js"><link rel="prefetch" href="/assets/js/44.7669f3e2.js"><link rel="prefetch" href="/assets/js/45.2fb532f4.js"><link rel="prefetch" href="/assets/js/46.0cc86442.js"><link rel="prefetch" href="/assets/js/47.30448b83.js"><link rel="prefetch" href="/assets/js/48.8893a5ed.js"><link rel="prefetch" href="/assets/js/49.ed7be1ae.js"><link rel="prefetch" href="/assets/js/5.d8a5933e.js"><link rel="prefetch" href="/assets/js/50.e4af394b.js"><link rel="prefetch" href="/assets/js/51.502ca2a7.js"><link rel="prefetch" href="/assets/js/52.f9768ea6.js"><link rel="prefetch" href="/assets/js/53.0c762369.js"><link rel="prefetch" href="/assets/js/54.dad23d00.js"><link rel="prefetch" href="/assets/js/55.4298d6a4.js"><link rel="prefetch" href="/assets/js/56.d8505fa7.js"><link rel="prefetch" href="/assets/js/57.63d197ce.js"><link rel="prefetch" href="/assets/js/58.ae9a3671.js"><link rel="prefetch" href="/assets/js/59.cb04d7cd.js"><link rel="prefetch" href="/assets/js/6.a83fef9a.js"><link rel="prefetch" href="/assets/js/60.0cedb385.js"><link rel="prefetch" href="/assets/js/61.a5c3f820.js"><link rel="prefetch" href="/assets/js/62.fc2d969d.js"><link rel="prefetch" href="/assets/js/63.53f087e3.js"><link rel="prefetch" href="/assets/js/64.9384bc9a.js"><link rel="prefetch" href="/assets/js/65.bb5db767.js"><link rel="prefetch" href="/assets/js/66.86940f42.js"><link rel="prefetch" href="/assets/js/67.37215862.js"><link rel="prefetch" href="/assets/js/68.e0c14875.js"><link rel="prefetch" href="/assets/js/69.276f0d65.js"><link rel="prefetch" href="/assets/js/7.7e7cde5e.js"><link rel="prefetch" href="/assets/js/70.0fb38ae4.js"><link rel="prefetch" href="/assets/js/71.7c824b27.js"><link rel="prefetch" href="/assets/js/72.bc39810c.js"><link rel="prefetch" href="/assets/js/73.9917d9a4.js"><link rel="prefetch" href="/assets/js/74.7912f7da.js"><link rel="prefetch" href="/assets/js/75.c193b7ec.js"><link rel="prefetch" href="/assets/js/76.ecd4e536.js"><link rel="prefetch" href="/assets/js/77.842c5aba.js"><link rel="prefetch" href="/assets/js/78.0a67366d.js"><link rel="prefetch" href="/assets/js/79.324df7d4.js"><link rel="prefetch" href="/assets/js/8.7063c274.js"><link rel="prefetch" href="/assets/js/80.68c6326b.js"><link rel="prefetch" href="/assets/js/81.a7df7b21.js"><link rel="prefetch" href="/assets/js/82.abd9c0c2.js"><link rel="prefetch" href="/assets/js/83.fd0d8457.js"><link rel="prefetch" href="/assets/js/84.148b432c.js"><link rel="prefetch" href="/assets/js/85.32148693.js"><link rel="prefetch" href="/assets/js/86.7dc5fe11.js"><link rel="prefetch" href="/assets/js/87.bd1be392.js"><link rel="prefetch" href="/assets/js/88.2c0b86aa.js"><link rel="prefetch" href="/assets/js/89.3038cc8d.js"><link rel="prefetch" href="/assets/js/90.fb4057a1.js"><link rel="prefetch" href="/assets/js/91.4aa5adaf.js"><link rel="prefetch" href="/assets/js/92.aea0a62e.js"><link rel="prefetch" href="/assets/js/93.e2d0e9a7.js"><link rel="prefetch" href="/assets/js/94.a9e33a20.js"><link rel="prefetch" href="/assets/js/95.7c55098e.js"><link rel="prefetch" href="/assets/js/96.c8dfe1c0.js"><link rel="prefetch" href="/assets/js/97.35fc7df3.js"><link rel="prefetch" href="/assets/js/98.551b3ede.js"><link rel="prefetch" href="/assets/js/99.a8f5ffc4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6bc9bf16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="wrap"><div class="theme-container container no-sidebar"><header class="navbar"><div class="nav-header"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" class="logo"> <span class="site-name can-hide">
        Myfun's Blog
      </span></a> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/interview/" class="nav-link">InterviewMap</a></div><div class="nav-item"><a href="https://zhangximufeng.github.io/css_tricks/" target="_blank" rel="noopener noreferrer" class="nav-link">CSS_Tricks</a></div><div class="nav-item"><a href="https://zhangximufeng.github.io/js_tricks/" target="_blank" rel="noopener noreferrer" class="nav-link">JS_Tricks</a></div><div class="nav-item"><a href="/tags/" class="nav-link">Tags</a></div><div class="nav-item"><a href="https://github.com/zhangximufeng" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></div><div class="nav-item"><a href="https://zhangximufeng.github.io/animate_resume_ts/" target="_blank" rel="noopener noreferrer" class="nav-link">About</a></div> <!----></nav> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/interview/" class="nav-link">InterviewMap</a></div><div class="nav-item"><a href="https://zhangximufeng.github.io/css_tricks/" target="_blank" rel="noopener noreferrer" class="nav-link">CSS_Tricks</a></div><div class="nav-item"><a href="https://zhangximufeng.github.io/js_tricks/" target="_blank" rel="noopener noreferrer" class="nav-link">JS_Tricks</a></div><div class="nav-item"><a href="/tags/" class="nav-link">Tags</a></div><div class="nav-item"><a href="https://github.com/zhangximufeng" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></div><div class="nav-item"><a href="https://zhangximufeng.github.io/animate_resume_ts/" target="_blank" rel="noopener noreferrer" class="nav-link">About</a></div> <!----></nav> <!----></div> <div class="page-container"><div><div class="page card"><div class="content-header"><!----> <span class="page-timestamp">2018-09-10</span></div> <div class="content"><p></p><div class="table-of-contents"><ul><li><a href="#udp">UDP</a><ul><li><a href="#面向报文">面向报文</a></li><li><a href="#不可靠性">不可靠性</a></li><li><a href="#高效">高效</a></li><li><a href="#传输方式">传输方式</a></li></ul></li><li><a href="#tcp">TCP</a><ul><li><a href="#头部">头部</a></li><li><a href="#状态机">状态机</a></li><li><a href="#arq-协议">ARQ 协议</a></li><li><a href="#滑动窗口">滑动窗口</a></li><li><a href="#拥塞处理">拥塞处理</a></li></ul></li><li><a href="#http">HTTP</a><ul><li><a href="#post-和-get-的区别">Post 和 Get 的区别</a></li><li><a href="#常见状态码">常见状态码</a></li><li><a href="#http-首部">HTTP 首部</a></li></ul></li><li><a href="#https">HTTPS</a><ul><li><a href="#tls">TLS</a></li></ul></li><li><a href="#http-2-0">HTTP 2.0</a><ul><li><a href="#二进制传输">二进制传输</a></li><li><a href="#多路复用">多路复用</a></li><li><a href="#header-压缩">Header 压缩</a></li><li><a href="#服务端-push">服务端 Push</a></li><li><a href="#quic">QUIC</a></li></ul></li></ul></div><p></p> <h1 id="udp"><a href="#udp" aria-hidden="true" class="header-anchor">#</a> UDP</h1> <h2 id="面向报文"><a href="#面向报文" aria-hidden="true" class="header-anchor">#</a> 面向报文</h2> <p>UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。</p> <p>具体来说</p> <ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li> <li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul> <h2 id="不可靠性"><a href="#不可靠性" aria-hidden="true" class="header-anchor">#</a> 不可靠性</h2> <ol><li>UDP 是无连接的，也就是说通信不需要建立和断开连接。</li> <li>UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的</li> <li>UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</li></ol> <h2 id="高效"><a href="#高效" aria-hidden="true" class="header-anchor">#</a> 高效</h2> <p>因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p> <p><img src="https://user-gold-cdn.xitu.io/2018/5/1/163195b245ceb89c?w=831&h=170&f=png&s=22793" alt></p> <p>头部包含了以下几个数据</p> <ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li> <li>整个数据报文的长度</li> <li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul> <h2 id="传输方式"><a href="#传输方式" aria-hidden="true" class="header-anchor">#</a> 传输方式</h2> <p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p> <h1 id="tcp"><a href="#tcp" aria-hidden="true" class="header-anchor">#</a> TCP</h1> <h2 id="头部"><a href="#头部" aria-hidden="true" class="header-anchor">#</a> 头部</h2> <p>TCP 头部比 UDP 头部复杂的多</p> <p><img src="https://camo.githubusercontent.com/95afcbd881d30014409de68e587279bf68c0cc60/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f312f313633316265343562303834653462633f773d38353826683d33303526663d706e6726733d3632313132" alt="img"></p> <p>对于 TCP 头部来说，以下几个字段是很重要的</p> <ul><li>Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li> <li>Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li> <li>Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制</li> <li>标识符
<ul><li>URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li> <li>ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li> <li>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li> <li>rST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li> <li>SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li> <li>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。</li></ul></li></ul> <h2 id="状态机"><a href="#状态机" aria-hidden="true" class="header-anchor">#</a> 状态机</h2> <p>HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态</p> <p><img src="https://camo.githubusercontent.com/58a7af1e7302b6d5ac57d3227e8023195e14eec4/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f312f313633316265663965336336303033353f773d3132383026683d39363526663d706e6726733d313031343332" alt></p> <p>TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。</p> <p>在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间。</p> <h3 id="建立连接三次握手"><a href="#建立连接三次握手" aria-hidden="true" class="header-anchor">#</a> 建立连接三次握手</h3> <p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631bf1e79b3cd42?w=666&h=426&f=png&s=32121" alt></p> <p>在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。</p> <p>起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。</p> <p><strong>第一次握手</strong></p> <p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入  SYN-SENT 状态，<code>x</code> 表示客户端的数据通信初始序号。</p> <p><strong>第二次握手</strong></p> <p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p> <p><strong>第三次握手</strong></p> <p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p> <p>PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。</p> <p><strong>你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？</strong></p> <p>因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p> <p>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p> <p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p> <h3 id="断开链接四次握手"><a href="#断开链接四次握手" aria-hidden="true" class="header-anchor">#</a> 断开链接四次握手</h3> <p><img src="https://camo.githubusercontent.com/5d766604499012c6bb14e5a9f1c5d4f489ba6773/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f322f313633316662383037663263366331623f773d36343026683d35313226663d706e6726733d3331303539" alt></p> <p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p> <p><strong>第一次握手</strong></p> <p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p> <p><strong>第二次握手</strong></p> <p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p> <p><strong>第三次握手</strong></p> <p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p> <p>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</p> <p><strong>第四次握手</strong></p> <p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p> <p><strong>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</strong></p> <p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p> <h2 id="arq-协议"><a href="#arq-协议" aria-hidden="true" class="header-anchor">#</a> ARQ 协议</h2> <p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ</p> <h3 id="停止等待-arq"><a href="#停止等待-arq" aria-hidden="true" class="header-anchor">#</a> 停止等待 ARQ</h3> <p><strong>正常传输过程</strong></p> <p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p> <p><strong>报文丢失或出错</strong></p> <p>在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p> <p>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传。</p> <p>PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。</p> <p><strong>ACK 超时或丢失</strong></p> <p>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p> <p>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p> <p><strong>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。</strong></p> <h3 id="连续-arq"><a href="#连续-arq" aria-hidden="true" class="header-anchor">#</a> 连续 ARQ</h3> <p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p> <h3 id="累计确认"><a href="#累计确认" aria-hidden="true" class="header-anchor">#</a> 累计确认</h3> <p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。</p> <p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下文说到。</p> <h2 id="滑动窗口"><a href="#滑动窗口" aria-hidden="true" class="header-anchor">#</a> 滑动窗口</h2> <p>在上面小节中讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。</p> <p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</p> <p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1632f25c587ffd54?w=660&h=270&f=png&s=37109" alt></p> <p>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p> <p>当发送端接收到应答报文后，会随之将窗口进行滑动</p> <p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1632f25cca99c8f4?w=660&h=210&f=png&s=24554" alt></p> <p>滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p> <h3 id="zero-窗口"><a href="#zero-窗口" aria-hidden="true" class="header-anchor">#</a> Zero 窗口</h3> <p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p> <h2 id="拥塞处理"><a href="#拥塞处理" aria-hidden="true" class="header-anchor">#</a> 拥塞处理</h2> <p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p> <p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p> <h3 id="慢开始算法"><a href="#慢开始算法" aria-hidden="true" class="header-anchor">#</a> 慢开始算法</h3> <p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p> <p>慢开始算法步骤具体如下</p> <ol><li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li> <li>每过一个 RTT 就将窗口大小乘二</li> <li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li></ol> <h3 id="拥塞避免算法"><a href="#拥塞避免算法" aria-hidden="true" class="header-anchor">#</a> 拥塞避免算法</h3> <p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p> <p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p> <ul><li>将阈值设为当前拥塞窗口的一半</li> <li>将拥塞窗口设为 1 MSS</li> <li>启动拥塞避免算法</li></ul> <h3 id="快速重传"><a href="#快速重传" aria-hidden="true" class="header-anchor">#</a> 快速重传</h3> <p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p> <p><strong>TCP Taho 实现如下</strong></p> <ul><li>将阈值设为当前拥塞窗口的一半</li> <li>将拥塞窗口设为 1 MSS</li> <li>重新开始慢开始算法</li></ul> <p><strong>TCP Reno 实现如下</strong></p> <ul><li>拥塞窗口减半</li> <li>将阈值设为当前拥塞窗口</li> <li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li> <li>使用拥塞避免算法</li></ul> <h3 id="tcp-new-ren-改进后的快恢复"><a href="#tcp-new-ren-改进后的快恢复" aria-hidden="true" class="header-anchor">#</a> TCP New Ren 改进后的快恢复</h3> <p><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p> <p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p> <p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p> <h1 id="http"><a href="#http" aria-hidden="true" class="header-anchor">#</a> HTTP</h1> <p>HTTP 协议是个无状态协议，不会保存状态。</p> <h2 id="post-和-get-的区别"><a href="#post-和-get-的区别" aria-hidden="true" class="header-anchor">#</a> Post 和 Get 的区别</h2> <p>先引入副作用和幂等的概念。</p> <p>副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</p> <p>幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。</p> <p>在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</p> <p>在技术上说：</p> <ul><li>Get 请求能缓存，Post 不能</li> <li>Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</li> <li>Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术</li> <li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li> <li>Post 支持更多的编码类型且不对数据类型限制</li></ul> <h2 id="常见状态码"><a href="#常见状态码" aria-hidden="true" class="header-anchor">#</a> 常见状态码</h2> <p><strong>2XX 成功</strong></p> <ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li> <li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li> <li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li> <li>206 Partial Content，进行范围请求</li></ul> <p><strong>3XX 重定向</strong></p> <ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li> <li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li> <li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li> <li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li> <li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul> <p><strong>4XX 客户端错误</strong></p> <ul><li>400 bad request，请求报文存在语法错误</li> <li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li> <li>403 forbidden，表示对请求资源的访问被服务器拒绝</li> <li>404 not found，表示在服务器上没有找到请求的资源</li></ul> <p><strong>5XX 服务器错误</strong></p> <ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li> <li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li> <li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul> <h2 id="http-首部"><a href="#http-首部" aria-hidden="true" class="header-anchor">#</a> HTTP 首部</h2> <table><thead><tr><th style="text-align:center">通用字段</th> <th style="text-align:center">作用</th></tr></thead> <tbody><tr><td style="text-align:center">Cache-Control</td> <td style="text-align:center">控制缓存的行为</td></tr> <tr><td style="text-align:center">Connection</td> <td style="text-align:center">浏览器想要优先使用的连接类型，比如  <code>keep-alive</code></td></tr> <tr><td style="text-align:center">Date</td> <td style="text-align:center">创建报文时间</td></tr> <tr><td style="text-align:center">Pragma</td> <td style="text-align:center">报文指令</td></tr> <tr><td style="text-align:center">Via</td> <td style="text-align:center">代理服务器相关信息</td></tr> <tr><td style="text-align:center">Transfer-Encoding</td> <td style="text-align:center">传输编码方式</td></tr> <tr><td style="text-align:center">Upgrade</td> <td style="text-align:center">要求客户端升级协议</td></tr> <tr><td style="text-align:center">Warning</td> <td style="text-align:center">在内容中可能存在错误</td></tr></tbody></table> <table><thead><tr><th style="text-align:center">请求字段</th> <th style="text-align:center">作用</th></tr></thead> <tbody><tr><td style="text-align:center">Accept</td> <td style="text-align:center">能正确接收的媒体类型</td></tr> <tr><td style="text-align:center">Accept-Charset</td> <td style="text-align:center">能正确接收的字符集</td></tr> <tr><td style="text-align:center">Accept-Encoding</td> <td style="text-align:center">能正确接收的编码格式列表</td></tr> <tr><td style="text-align:center">Accept-Language</td> <td style="text-align:center">能正确接收的语言列表</td></tr> <tr><td style="text-align:center">Expect</td> <td style="text-align:center">期待服务端的指定行为</td></tr> <tr><td style="text-align:center">From</td> <td style="text-align:center">请求方邮箱地址</td></tr> <tr><td style="text-align:center">Host</td> <td style="text-align:center">服务器的域名</td></tr> <tr><td style="text-align:center">If-Match</td> <td style="text-align:center">两端资源标记比较</td></tr> <tr><td style="text-align:center">If-Modified-Since</td> <td style="text-align:center">本地资源未修改返回 304（比较时间）</td></tr> <tr><td style="text-align:center">If-None-Match</td> <td style="text-align:center">本地资源未修改返回 304（比较标记）</td></tr> <tr><td style="text-align:center">User-Agent</td> <td style="text-align:center">客户端信息</td></tr> <tr><td style="text-align:center">Max-Forwards</td> <td style="text-align:center">限制可被代理及网关转发的次数</td></tr> <tr><td style="text-align:center">Proxy-Authorization</td> <td style="text-align:center">向代理服务器发送验证信息</td></tr> <tr><td style="text-align:center">Range</td> <td style="text-align:center">请求某个内容的一部分</td></tr> <tr><td style="text-align:center">Referer</td> <td style="text-align:center">表示浏览器所访问的前一个页面</td></tr> <tr><td style="text-align:center">TE</td> <td style="text-align:center">传输编码方式</td></tr></tbody></table> <table><thead><tr><th style="text-align:center">响应字段</th> <th style="text-align:center">作用</th></tr></thead> <tbody><tr><td style="text-align:center">Accept-Ranges</td> <td style="text-align:center">是否支持某些种类的范围</td></tr> <tr><td style="text-align:center">Age</td> <td style="text-align:center">资源在代理缓存中存在的时间</td></tr> <tr><td style="text-align:center">ETag</td> <td style="text-align:center">资源标识</td></tr> <tr><td style="text-align:center">Location</td> <td style="text-align:center">客户端重定向到某个 URL</td></tr> <tr><td style="text-align:center">Proxy-Authenticate</td> <td style="text-align:center">向代理服务器发送验证信息</td></tr> <tr><td style="text-align:center">Server</td> <td style="text-align:center">服务器名字</td></tr> <tr><td style="text-align:center">WWW-Authenticate</td> <td style="text-align:center">获取资源需要的验证信息</td></tr></tbody></table> <table><thead><tr><th style="text-align:center">实体字段</th> <th style="text-align:center">作用</th></tr></thead> <tbody><tr><td style="text-align:center">Allow</td> <td style="text-align:center">资源的正确请求方式</td></tr> <tr><td style="text-align:center">Content-Encoding</td> <td style="text-align:center">内容的编码格式</td></tr> <tr><td style="text-align:center">Content-Language</td> <td style="text-align:center">内容使用的语言</td></tr> <tr><td style="text-align:center">Content-Length</td> <td style="text-align:center">request body 长度</td></tr> <tr><td style="text-align:center">Content-Location</td> <td style="text-align:center">返回数据的备用地址</td></tr> <tr><td style="text-align:center">Content-MD5</td> <td style="text-align:center">Base64加密格式的内容 MD5检验值</td></tr> <tr><td style="text-align:center">Content-Range</td> <td style="text-align:center">内容的位置范围</td></tr> <tr><td style="text-align:center">Content-Type</td> <td style="text-align:center">内容的媒体类型</td></tr> <tr><td style="text-align:center">Expires</td> <td style="text-align:center">内容的过期时间</td></tr> <tr><td style="text-align:center">Last_modified</td> <td style="text-align:center">内容的最后修改时间</td></tr></tbody></table> <p>PS：缓存相关已在别的模块中写完，你可以 <a href="/fe/浏览器机制.html">阅读该小节</a></p> <h1 id="https"><a href="#https" aria-hidden="true" class="header-anchor">#</a> HTTPS</h1> <p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p> <h2 id="tls"><a href="#tls" aria-hidden="true" class="header-anchor">#</a> TLS</h2> <p>TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。</p> <p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p> <p><strong>对称加密</strong>：</p> <p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p> <p><strong>非对称加密</strong>：</p> <p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p> <p><strong>TLS 握手过程如下图：</strong></p> <p><img src="/assets/img/image-20180906141011007.ac6860c2.png" alt="image-20180906141011007"></p> <ol><li>客户端发送一个随机值，需要的协议和加密方式</li> <li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li> <li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li> <li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li></ol> <p>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p> <p>PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。</p> <h1 id="http-2-0"><a href="#http-2-0" aria-hidden="true" class="header-anchor">#</a> HTTP 2.0</h1> <p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p> <p>在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p> <p>你可以通过 <a href="https://http2.akamai.com/demo" target="_blank" rel="noopener noreferrer">该链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 感受下 HTTP 2.0 比 HTTP 1.X 到底快了多少。</p> <p><img src="https://camo.githubusercontent.com/a01a8472371ab84d0d60ecdec6865a3231b6bdbf/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31322f313633353432636136316561666631373f773d39323926683d35313226663d706e6726733d323435363730" alt></p> <p>在 HTTP 1.X 中，因为队头阻塞的原因，你会发现请求是这样的</p> <p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c96df8563d?w=518&h=642&f=png&s=72417" alt></p> <p>在 HTTP 2.0 中，因为引入了多路复用，你会发现请求是这样的</p> <p><img src="https://camo.githubusercontent.com/e59343e0935d8c258c779d3b0f6031fe4b7e8f19/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31322f313633353432633964333132386337613f773d39303026683d36313626663d706e6726733d3731303134" alt></p> <h2 id="二进制传输"><a href="#二进制传输" aria-hidden="true" class="header-anchor">#</a> 二进制传输</h2> <p>HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p> <p><img src="https://camo.githubusercontent.com/428e7ba2a88a559f3fcb3466542f1fefa9a3ca16/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31322f313633353433633235653565396632333f773d38373426683d34353926663d706e6726733d3236333230" alt></p> <h2 id="多路复用"><a href="#多路复用" aria-hidden="true" class="header-anchor">#</a> 多路复用</h2> <p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</p> <p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p> <p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p> <p><img src="https://camo.githubusercontent.com/68286c96c8b3e175bf949069fe8345c426b1e869/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31322f313633353434323533316433653565653f773d34393426683d31333826663d706e6726733d39363336" alt></p> <h2 id="header-压缩"><a href="#header-压缩" aria-hidden="true" class="header-anchor">#</a> Header 压缩</h2> <p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p> <p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p> <h2 id="服务端-push"><a href="#服务端-push" aria-hidden="true" class="header-anchor">#</a> 服务端 Push</h2> <p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p> <p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。</p> <h2 id="quic"><a href="#quic" aria-hidden="true" class="header-anchor">#</a> QUIC</h2> <p>这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标很远大，希望替代 TCP 协议。</p> <ul><li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，</li></ul></div> <!----> <div class="content page-nav"><p class="inner"><span class="prev">
          ← <a href="/fe/11.Stream-1.html" class="prev">
            流的概念
          </a></span> <span class="next"><a href="/fe/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6.html">
            事件机制
          </a> →
        </span></p></div> <div id="comment-container"><div class="gt-container"><div class="gt-initing"><i class="gt-loader"></i> <p class="gt-initing-text">Gitalking ...</p></div> <!----> <!----> <div><div class="gt-header"><a class="gt-avatar-github"><span class="gt-ico gt-ico-github"><span class="gt-svg"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64 524C64 719.602 189.356 885.926 364.113 947.017 387.65799 953 384 936.115 384 924.767L384 847.107C248.118 863.007 242.674 773.052 233.5 758.001 215 726.501 171.5 718.501 184.5 703.501 215.5 687.501 247 707.501 283.5 761.501 309.956 800.642 361.366 794.075 387.658 787.497 393.403 763.997 405.637 743.042 422.353 726.638 281.774 701.609 223 615.67 223 513.5 223 464.053 239.322 418.406 271.465 381.627 251.142 320.928 273.421 269.19 276.337 261.415 334.458 256.131 394.888 302.993 399.549 306.685 432.663 297.835 470.341 293 512.5 293 554.924 293 592.81 297.896 626.075 306.853 637.426 298.219 693.46 258.054 747.5 262.966 750.382 270.652 772.185 321.292 753.058 381.083 785.516 417.956 802 463.809 802 513.5 802 615.874 742.99 701.953 601.803 726.786 625.381 750.003 640 782.295 640 818.008L640 930.653C640.752 939.626 640 948.664978 655.086 948.665 832.344 888.962 960 721.389 960 524 960 276.576 759.424 76 512 76 264.577 76 64 276.576 64 524Z"></path>
</svg>
</span> <!----></span></a> <div class="gt-header-comment"><textarea placeholder="Leave a comment" class="gt-header-textarea"></textarea> <div class="gt-header-preview markdown-body hide"></div> <div class="gt-header-controls"><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" class="gt-header-controls-tip"><span class="gt-ico gt-ico-tip"><span class="gt-svg"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 366.949535c-16.065554 0-29.982212 13.405016-29.982212 29.879884l0 359.070251c0 16.167882 13.405016 29.879884 29.982212 29.879884 15.963226 0 29.879884-13.405016 29.879884-29.879884L541.879884 396.829419C541.879884 380.763865 528.474868 366.949535 512 366.949535L512 366.949535z"
    p-id="3083"></path>
  <path d="M482.017788 287.645048c0-7.776956 3.274508-15.553912 8.80024-21.181973 5.525732-5.525732 13.302688-8.80024 21.181973-8.80024 7.776956 0 15.553912 3.274508 21.079644 8.80024 5.525732 5.62806 8.80024 13.405016 8.80024 21.181973 0 7.776956-3.274508 15.656241-8.80024 21.181973-5.525732 5.525732-13.405016 8.697911-21.079644 8.697911-7.879285 0-15.656241-3.274508-21.181973-8.697911C485.292295 303.301289 482.017788 295.524333 482.017788 287.645048L482.017788 287.645048z"
    p-id="3084"></path>
  <path d="M512 946.844409c-239.8577 0-434.895573-195.037873-434.895573-434.895573 0-239.8577 195.037873-434.895573 434.895573-434.895573 239.755371 0 434.895573 195.037873 434.895573 434.895573C946.895573 751.806535 751.755371 946.844409 512 946.844409zM512 126.17088c-212.740682 0-385.880284 173.037274-385.880284 385.777955 0 212.740682 173.037274 385.777955 385.880284 385.777955 212.740682 0 385.777955-173.037274 385.777955-385.777955C897.777955 299.208154 724.740682 126.17088 512 126.17088z"
    p-id="3085"></path>
</svg>
</span> <span class="gt-ico-text">Markdown is supported</span></span></a> <!----> <button class="gt-btn gt-btn-preview"><span class="gt-btn-text">Preview</span> <!----></button> <button class="gt-btn gt-btn-login"><span class="gt-btn-text">Login with GitHub</span> <!----></button></div></div></div> <div class="gt-comments"><span></span> <p class="gt-comments-null">
                Be the first guy leaving a comment!
            </p> <!----></div></div></div></div></div></div> <!----></div> <div class="tool-group"><!----></div></div> <!----></div> <div class="background-mask" style="background:#f6f6f6;"></div></div></div>
    <script src="/assets/js/app.35b69267.js" defer></script><script src="/assets/js/9.5cab2997.js" defer></script>
  </body>
</html>
